
## 📚 TIL

---

### `개인 공부`
- [X] 스프링 MVC 1편 - 백엔드 웹 개발 핵심 기술 - 1,2,3 섹션
- [X] 자바 ORM 표준 JPA 프로그래밍 3장
- [ ]
- [ ]

---
### `짧은 정리`

#### `자바 ORG 표준 JPA 프로그래밍 3장`
- 엔티티매니저는 엔티티를 저장하고, 수정하고 , 삭제하고, 조회하는 등 엔티티와 관련된 모든 일을 처리한다.
- 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전
- 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제 발생
- 엔티티 메니저는 데이터베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않는다.
  - 트랜잭션을 시작할 때 커넥션을 획득
- `em.persist(member)` -> 엔티티 매니저를 사용해서 회원 엔티티를 `영속성 컨텍스트`에 저장

---
#### `엔티티의 생명주기`
- 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태
  - 엔티티 객체를 생성했지만 아직 저장하지 않은 상태
- 영속 : 영속성 컨텍스트에 저장된 상태
  - 영속성 컨텍스트에 의해 관리되는 상태
- 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
  - 영속성 컨텍스트를 닫거나 em.clear(), em.detach()를 사용해 분리한 상태
- 삭제 : 삭제된 상태
  - 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한 상태

#### `영속성 컨텍스트 특징`
```java
영속성 컨텍스트는 엔티티를 키와 벨류의 형태로 저장함
```
- 영속성 컨텍스트와 식별자 값
  - 엔티티를 식별자 값(@Id)으로 구분, `영속 상태는 식별자 값이 반드시 있어야 함`
- 영속성 컨텍스트와 데이터베이스 저장
  - 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하는데 이걸 플러시(flush)라 함.
- `영속성 컨텍스트가 엔티티를 관리하는 장점`
  - 1차 캐시
  - 동일성 보장
  - 트랜잭션을 감지하는 쓰기 지연
  - 변경 감지
  - 지연 로딩

#### 엔티티 조회
- 영속성 컨텍스트는 내부에 캐시를 가지고 있음(1차 캐시)
- 1차 캐시에는 키와 벨류의 형태로 식별자와 엔티티를 갖고 있음
- `em.find()`를 호출하면 JPA는 1차 캐시에서 엔티티를 먼저 찾음 -> 1차 캐시에 없으면 데이터 베이스에서 조회
- 만약 1차 캐시에 없으면 엔티티 매니저는 데이터베이스를 조회해 엔티티를 생성하고 1차 캐시에 저장 후 엔티티를 반환한다.
- 동일한 영속성 컨텍스트에서 조회한 같은 식별자의 엔티티는 동일성이 보장된다.

#### `쓰기지연`
- 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장하지 않고 `내부 쿼리 저장소`에 INSERT SQL을 차곡차곡 모아둔다.
- 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보내는데 이것을 트랜잭션을 지원하는 `쓰기 지연`이라 한다.
- em.persist(member) -> member를 영속화(1차 캐시에 저장 및 INSERT SQL 생성) -> 트랜잭션 커밋 -> 영속성 컨텍스트 플러시 -> SQL 쿼리 실행
