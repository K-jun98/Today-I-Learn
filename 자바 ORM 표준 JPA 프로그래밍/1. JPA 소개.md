# 1. JPA 소개

## `1.1 SQL을 직접 다룰 때 발생하는 문제점` 
<br>

### `1.1.1 반복,반복 그리고 반복`
- 데이터베이스는 객체 구조와는 다른 데이터 중심의 구조를 가지므로 객체를 데이터베이스에 직접 저장하거나 조회할 수는 없다.
- 개발자가 객체지향 애플리케이션과 데이터베이스 중간에서 SQL과 JDBC API 를 사용해서 변환 작업을 직접 해주어야 한다.
- 개발하려는 애플리케이션에서 사용하는 데이터베이스 테이블이 100개라면 무수히 많은 SQL을  작성해야 하고 이런 비슷한 일을 반복해야한다.
<br>

### `1.1.2 SQL에 의존적인 개발`
- 요구사항의 변경으로 테이블 컬럼을 추가하는 상황에 모든 SQL을 확인해야한다.
- 객체는 연관관계를 쉽게 추가 할 수 있지만 데이터베이스에 연관 정보를 저장하는 것은 복잡하다.

## `패러다임의 불일치`
<br>

- 예를 들어 회원 객체를 데이터베이스에 저장해야 하는데 회원 객체가 팀 객체를 참조하고 있다면, 회원 객체를 저장할 때
팀 객체도 저장해야 한다. 단순히 회원 객체만 저장하면 참조하는 팀 객체를 잃어버리는 문제가 발생한다.
자바는 이런 문제를 고려해 `객체를 파일로 바꾸는 직렬화`, `파일을 객체로 복구하는 역 직렬화` 기능을 지원한다. 하지만 이 방법은
직렬화된 객체를 탐색하기는 어렵다는 문제가 있다. `데이터베이스는 데이터 중심`으로 구조화되어 있고, 집합적인 사고를 요구한다.
그리고 `객체지향에서 존재하는 추상화,상속,다형성 같은 개념이 없다.` 객체와 관계형 데이터베이스는 지향하는 목적이 달라 둘의 기능과
표현 방법도 다르다. 이것을 객체와 관계형 데이터베이스의 `패러다임 불일치` 문제라 한다.

### `상속`
```java
abstract class Item {
    Long id;
    String name;
    int price;
}

class Album extends Item {
    String artist;
}

class Movie extends Item {
    String director;
    String actor;
}

class Book extends Item {
    String author;
    String isbn;
}
```
Album 객체를 저장하려면 다음 두 SQL을 만들어야 한다.
```sql
INSERT INTO ITEM...
INSERT INTO ALBUM...
```
예를 들어, Album을 조회한다면 ITEM과 ALBUM테이블을 조인해서 조회한 다음 그 결과로 Album 객체를 생성해야 한다.

### `JPA와 상속`
JPA는 상속과 관련된 패러다임의 불일치 문제를 개발자 대신 해결해준다. JPA를 사용해 Album객체를 저장한다면
```java
jpa.persist(album);
```
메서드를 통해 객체를 저장하면 된다. JPA는 다음 SQL을 실행해서 객체를 ITEM,ALBUM 두 테이블에 나누어 저장한다.
```sql
INSERT INTO ITEM ...
INSERT INTO ALBUM ...
```
Album객체를 조회할때도 find() 메소드를 사용해 쉽게 조회가 가능하다.
```java
String albumId = "id100";
Album album = jpa.find(Album.class, albumId);
```
JPA는 ITEM과 ALBUM 두 테이블을 조인해서 필요한 데이터를 조회하고 그 결과를 반환한다.
<br>
### ```연관관계```
`객체는 참조`를 사용해서 다른 객체와 연관관계를 가지고 `참조에 접근해서 연관된 객체를 조회`한다. 반면에 `테이블은
왜래 키`를 사용해서 다른 테이블과 연관관계를 가지고 `조인을 사용해서 연관된 테이블을 조회`한다.

```java
class Member {
    Team team;
    ...
    Team getTeam() {
        return team;
    } 
}

class Team {
    ...
}
```
 `객체는 참조가 있는 방향으로만 조회`할 수 있다. 위 예에서 member.getTeam() 은 가능하지만 반대 방향인 team.getMember() 는 참조가 없으므로
불가능하다. 반면에 `테이블은 외래 키 하나로 MEMBER JOIN TEAM 도 가능하지만 TEAM JOIN MEMBER도 가능`하다.

### `객체를 테이블에 맞추어 모델링`
```java
class Member {

    String id;
    Long teamId; //TEAM_ID FK 컬럼 사용
    String username;
}

class Team {
    Long id;
    String name;
}
```
객체를 테이블에 맞추어 모델링하면 객체를 테이블에 저장하거나 조회할 때는 편리하다. 그런데 여기서 TEAM_ID 외래 키의 값을 그대로
보관하는 teamId필드에는 문제가 있다. 데이터베이스는 조인이라는 기능이 있으므로 외래 키의 값을 그대로 보관해도 된다. 하지만
객체는 연관된 객체의 참조를 보관해야 찾을 수 있다.위 방식을 따르면 좋은 객체 모델링은 기대하기 어렵고 결국 객체지향의 특징을 잃어버리게 된다.

<Br>

### `JPA와 연관관계`
- JPA는 연관관계와 관련된 패러다임의 불일치 문제를 해결해준다.
```java
member.setTeam(team); //회원과 팀 연관관계 설정
jpa.persist(member); // 회원과 연관관계 함께 저장
```
개발자는 회원과 팀의 관계를 설정하고 회원 객체를 저장하면 된다. `JPA는 team의 참조를 외래 키로 변환해서 적절한 INSERT SQL을 데이터베이스에
전달`한다. `객체를 조회할 때 외래 키를 참조로 변환하는 일도 JPA가 처리해준다.`

### `객체 그래프 탐색`
<img width="550" alt="그래프" src="https://user-images.githubusercontent.com/101342145/213611217-1aaaa48a-3006-46cf-ad11-43e6aeba4ab9.png">

`member.getOrder().getOrderItem()` 같은 코드를 객체 그래프 탐색이라고 한다. 객체는 마음껏 객체 그래프를 탐색할 수 있어야 한다.
그런데 마음껏 탐색할 수 있을까?
```sql
SELECT M.*, T.*
FROM MEMBER M
         JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID
```
예를 들어 MemberDAO에서 member 객체를 조회할 때 이런 SQL을 실행해서 회원과 팀에 대한 데이터만 조회했다면 member.getTeam()은 성공하지만
다음처럼 다른 객체는 데이터가 없으므로 탐색할 수 없다.<br>
```java
member.getOrder(); // null <br>
```
`SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다.` 이것은 객체지향 개발자에겐 너무 큰 제약이다.

<br>
<br>

### `JPA와 객체 그래프 탐색`
JPA를 사용하면 객체 그래프를 마음껏 탐색할 수 있다. JPA는 연관된 객체를 사용하는 시점에 적절한 SQL을 실행한다.따라서 연관된 객체를
신뢰하고 마음껏 조회할 수 있다. 이 기능은 실제 객체를 사용하는 시점까지 데이터베ㅣ스 조회를 미룬다고 해서 `지연 로딩`이라 한다.
```java
// 처음 조회 시점에 SELECT MEMBER SQL
Member member = jpa.find(Member.class, memberId);

Order order = member.gerOrder();
order.getOrderDate(); // Order를 사용하는 시점에 SELECT ORDER SQL
```
Member를 사용할 때마다 Order를 함께 사용하면, 이렇게 한 테이블씩 조회하는 것보다는 Member를 조회하는 시점에 SQL 조인을 사용해서
Member와 Order를 함께 조회하는 것이 효과적이다. 물론 즉시 함께 조회하는 것도 가능하다.


### `정리`
- 객체 모델과 관계형 데이터베이스 모델은 지향하는 패러다임이 서로 다르다.
- 정교한 객체 모델링을 할수록 패러다임의 불일치 문제가 더 커자고 비용도 많아진다.
- JPA는 패러다임의 불일치 문제를 해결해주고 정교한 객체 모델링을 유지하게 도와준다.

<br>

## `JPA란 무엇인가?`
<img width="600" alt="JPA" src="https://user-images.githubusercontent.com/101342145/213613241-0de96f40-251b-4a55-9f8d-3afbfebf5bdd.png">
<br>

JPA는 자바 진영의 ORM 기술 표준이다. ORM이란 Object-Relational-Mapping 즉 객체와 관계형 데이터베이스를 매핑한다는 뜻이다.
`객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결`해준다.
ORM 프레임워크는 단순히 SQL을 개발자 대신 생성해서 데이터베이스에 전달해주는 것뿐만 아니라 다양한 패러당ㅁ의 불일치 문제들도 해결해준다.
덕분에 개발자는 데이터 중심인 관계형 데이터베이스를 사용해도 객체지향 애플리케이션 개발에 집중할 수 있다.

### 'JPA를 사용해야 하는 이유'
<details>
<summary>생산성</summary>
<div markdown="1">
JPA를 사용하면 자바 컬렉션에 객체를 저장하듯이 JPA에게 저장할 객체를 전달하면 된다.SQL을 작성하고 JDBC를 사용하는 지루하고 반복적인 일은 JPA가 처리해 준다.
이런 기능들을 사용하면 데이터베이스 설계 중심에서 객체 설계 중심으로 역전시킬 수 있다.
</div>
</details>

<br>

<details>
<summary>유지보수</summary>
<div markdown="1">
SQL을 직접 다루면 엔티티에 필드를 하나만 추가해도 관련된 등록, 수정, 조회 SQL과 결과를 매핑하기 위한 JDBC API 코드를 모두 변경해야 했다.
반면에 JPA를 사용하면 이런과정을 JPA가 대신 처리해 주므로 수정해야할 코드가 줄어든다. 또한, 패러다임의 불일치 문제를 해결해주므로 객체지향 언어가 가진 장점들을
활용해서 유연하고 유지보수하기 좋은 도메인 모델을 설계할 수 있다.
</div>
</details>

<br>

<details>
<summary>성능</summary>
<div markdown="1">
JPA는 애플리케이션과 데이터베이스 사이에서 다양한 성능 최적화 기회를 제공한다. JPA는 애플리케이션과 데이터베이스 사이에서 영속성 컨텍스트의 1차캐시를 활용하는등
성능에서도 이점이 있다.
</div>
</details>

<br>

<details>
<summary>데이터 접근 추상화와 벤더 독립성</summary>
<div markdown="1">
관계형 데이터베이스는 같은 기능도 벤더마다 사용법이 다른 경우가 많다. SQL 문법이 대표적이다. 하지만 JPA를 사용하면 특정 데이터베이스 기술에 종속되지 않아도 된다.
</div>
</details>

<br><br>

### `Referense`
김영한 - 자바 ORM 표준 JPA 프로그래밍





































