## 연관관계 매핑시 고려사항 3가지

### `다중성`
- 다대일: @ManyToOne
- 일대다: @OneToMany
- 일대일: @OneToOne
- 다대다: @ManyToMany


단방향, 양방향
- 테이블
  - 외래 키 하나로 양쪽 조인 가능
  - 방향이라는 개념이 없음
- 객체
  - 참조용 필드가 있어야 접근가능
  - 한쪽만 참조하면 단방향
  - 양쪽으 서로 참조하면 양방향
  
  <br>
  
- 연관관계의 주인
  - `테이블은 외래 키 하나`로 두 테이블이 연관관계를 맺음
  - 객체 양방향 관계는 A->B, B->A 처럼 `참조가 2군데`
  - 테이블의 외래 키를 관리할 곳을 지정해야함
  - 연관관계의 주인: 외래 키를 관리하는 참조
  - 주인의 반대편: 외래 키에 영향을 주지 않음, Read Only`

### 1:N 관계에서 N에 외래 키가 있어야하는 이유
```
객체의 관점이 아니라 테이블의 관점에서 생각해 보면 쉽다. 테이블에서 외래키를 어디에 갖고있어야 하는가?
1:N관계에서 외래키는 N이 갖고있어야한다. 여기에서 팀(1)과 팀원(N) 이라는 테이블이 있을때 주인이 팀이라고 생각해보자
그러면 team.remove(member); 가 실행되면 team에서 멤버를 지웠는데 업데이트 쿼리는 외래키를 갖고있는 member에서 발생하게 된다.
그러면 반대로 주인이 멤버라고 생각해보자 member.remove(team)을 실행하게되면 member에서 쿼리가 발생하게 되고  
```
`ORM은 객체 관계 매핑을 돕는 도구지 객체지향을 온전히 충족할 수 없다.`


## 다대일 [N:1]

### `다대일 단방향`
<img width="500" alt="스크린샷 2023-01-24 오후 8 47 47" src="https://user-images.githubusercontent.com/101342145/214284974-4fe4d23c-8efe-4172-ba1c-2bab9966cd63.png">
- Member랑 Team일때 N:1의 관계가 되고 N에 외래키가 셋팅된다. 외래키를 갖고있는 테이블 엔티티에 참조를 걸어주면 된다.
- 다대일의 반대로는 일대다가 된다.

### `다대일 양방향`
<img width="500" alt="스크린샷 2023-01-24 오후 8 53 01" src="https://user-images.githubusercontent.com/101342145/214285056-6436b8dd-d83d-4308-b846-01d3a70d56b5.png">
- 외래 키가 있는 쪽이 연관관계의 주인
- 양쪽을 서로 참조하도록 개발

 
## 일대다 [1:N]
### `일대다 단방향`
 <img width="500" alt="스크린샷 2023-01-24 오후 9 08 41" src="https://user-images.githubusercontent.com/101342145/214288016-494e3f50-6750-49b5-82ec-d9a89028e556.png">

- 일대다 단방향 매핑의 단점
  - `엔티티가 관리하는 외래 키가 다른 테이블에 있음`
  - 연관관계 관리를 위해 추가로 UPDATE SQL 실행
- 일대다 단방향 매핑보다는 `다대일 양방향 매핑을 사용`하자
- 일대다 단방향은 일대다에서 일이 연관관계의 주인
- 테이블 일대다 관계는 항상 다 쪽에 외래 키가 있음
- 객체와 테이블의 차이 때문에 `반대편 테이블의 외래 키를 관리하는 특이한 구조`
- `@JoinColumn`을 꼭 사용해야함. 그렇지 않으면 조인 테이블 방식을 사용(중간에 테이블을 하나 추가함)

### `문제점`
- 객체에서는 Team에 List<Member>가 되어있지만 테이블 관계에서는 Member의 Team_ID를 외래키로 갖고있다.
외래 키와 객체의 참조 위치가 다른 상황이라 불필요한 쿼리가 발생한다.

### `일대다 양방향`
<img width="500" alt="스크린샷 2023-01-24 오후 10 37 49" src="https://user-images.githubusercontent.com/101342145/214309397-160cef76-6468-47f3-b849-692ea4f4ca87.png">

- 이런 매핑은 공식적으로 존재X
- @JoinColumn(`insertable=false, updatable=false`)
- `읽기 전용 필드`를 사용해서 양방향 처럼 사용하는 방법
- `다대일 양방향을 사용하자`

### `일대다와 다대일의 차이`

- 다대일에서는 객체 연관관계에서 다(N)가 주인이였지만 다대일에서 주인은 일(1)이 됨.

## 일대일 [1:1]

- `일대일` 관계는 그 반대도 `일대일`
- 주 테이블이나 대상 테이블 중에 외래 키 선택 가능
  - 주 테이블에 외래 키
  - 다상 테이블에 외래 키
- 외래 키에 데이터베이스 유니크 제약조건 추가 

<img width="500" alt="스크린샷 2023-01-25 오전 12 04 41" src="https://user-images.githubusercontent.com/101342145/214330523-2741eb0a-1e6b-4ffe-a367-d3541cf3c751.png">

- Member와 Locker는 1:1 관계
- 테이블에서 외래 키를 갖는쪽에 유니크 특성을 부여해야함.(1:1이기 때문에)
- 다대일(@ManyToOne) 단방향 매핑과 유사

<img width="500" alt="스크린샷 2023-01-25 오전 12 09 29" src="https://user-images.githubusercontent.com/101342145/214331243-fe1656fd-954e-4776-ae41-9f039720f662.png">

- 다대일 양방향 매핑 처럼 `외래 키가 있는 곳이 연관관계의 주인`
- 반대편은 `mappedBy` 적용

`아래와 같은 경우는 지원 불가`

<img width="500" alt="스크린샷 2023-01-25 오전 12 16 08" src="https://user-images.githubusercontent.com/101342145/214332935-5a089a4e-cfc1-4195-85b5-3b5f633c0913.png">

## 다대다 [N:N]

- 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없음
- 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야함
- `객체는 컬렉션을 사용해서 객체 2개로 다대다 관계 가능`
- `@ManyToMany`사용
- `@JoinTable`로 연결 테이블 지정

<img width="500" alt="스크린샷 2023-01-25 오전 12 34 12" src="https://user-images.githubusercontent.com/101342145/214337368-d7dfefda-fa8e-46ec-80ae-37780390ea90.png">

### `다대다 매핑의 한계`

- `편리해 보이지만 실무에서 사용X`
- 연결 테이블이 단순히 연결만 하고 끝나지 않음
- 주문시간, 수량 같은 데이터가 들어올 수 있음
