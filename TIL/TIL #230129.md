
## 📚 TIL

---

### `개인 공부`
- SOLID 원칙
- 인프런 `코딩으로 학습하는 리팩토링` 섹션0,1 수강
- @Builder를 클래스 레벨이 아닌 생성자 레벨에서 사용해야 하는 이유?






### `짧은 정리`

- SOLID 원칙
  - 단일 책임 원칙
    - 클래스는 단 한개의 책임을 가져야 한다.
    - 클래스를 변경하는 이유는 한 개여야 한다.
  - 개방 폐쇄 원칙
    - 확장에는 열려 있고, 변경에는 닫혀 있어야 한다.
    - 위에 말을 들으면 이게 무슨 말이지? 확장을 하는데 어떻게 변경을 안하지? 라는 생각이 들 수 있다.
    - 기능을 추가하거나 변경하면서 사용하던 코드는 수정하지 않는다.
  - 의존성역전의 원칙
    - 상위 모듈은 하위 모듈의 구현에 의존해서는 안 된다.
    - 하위의 모듈이 상위 모듈에 정의한 추상 타입에 의존 해야한다.
---
- 함수 선언 변경하기
  - 좋은 이름을 가진 함수는 함수가 어떻게 구현되었는지 코드를 보지 않아도 이름만 보고도 이해할 수 있다.
  - TIP `함수에 주석을 작성한 다음, 주석을 함수 이름으로 만들어 본다.`
- 변수 이름 바꾸기
  - 더 많이 사용되는 변수일수록 그 이름이 더 중요함
  - 다이나믹 타입을 지원하는 언어에서는 타입을 이름에 넣기도 함
  - 여러 함수에 걸쳐 쓰는 필드 이름에는 더 많이 고민하고 이름을 짓는다.
- 필드 이름 바꾸기
  - Record 자료 구조의 필드 이름은 프로그럄 전반에 걸쳐 참조될 수 있기 때문에 매우 중요하다.
---
- `클래스 위에 @Builder 사용 시 문제점`
  - 클래스 레벨에 @Builder를 서언언하면 모든 필드 멤버에 대해서 매개변수를 받는 생성자를 만든다.
    - 이 경우에 Id,CreatedAt,CreatedBy같은 생성 시 받지 않아야할 데이터도 빌더에 노출이 된다.
    - 객체 생성시 꼭 필요한 데이터들만 생성자로 만들어주고 생성자위에 @Builder를 사용하자
---
- `IoC(Inversion of Control)-제어의 역전이란?`
  - 스프링 애플리케이션에서는 오브젝트(빈)의 생명과 의존 관계 설정, 사용, 제거 등의 작업을 애플리케이션 코드 대신 스프링 컨테이너가 담당
  - 이를 스프링 컨테이너가 코드 대신 오브젝트에 대한 제어권을 갖고 있다고 해서 IoC라고 부름
  - 따라서, 스프링 컨테이너를 IoC컨테이너라고도  부른다

### `개인 적인 생각`
- 책임이라는 것을 변경될 수 있는 이유 라고봐도 되는것일까..?
- 확장은 새로운 요구사항(기능)을 추가했을때 새로운 클래스를 추가함으로써 기능을 확장하는 것이다.
- 변경은 확장이 이루어 졌을때 해당 코드를 호출하는 쪽에서 변경이 발생하지 않으면 닫혀 있다는 것이다.